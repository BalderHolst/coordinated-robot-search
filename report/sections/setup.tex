\section{Setup}
\label{sec:setup}

\subsection{Hardware}
% TODO: Describe the robot we are designing for
% TODO: Describe the sensors available
% TODO: Describe that we assume the robot to have some sort of communication method

For this project a differential drive robot with camera, lidar, odometry and communication capabilities is assumed. Lidar and odometry are used for localization using AMCL as discussed later ({\color{red} DISCUSS THIS}), the camera is used to look for the search object and a global communication channel is needed for the robots to share data. To get realistic parameters and to make use of ready made 3D models, URDF files and robot parameters, the Turtlebot 4 \cite{tb4} was chosen as the target platform. It is, however, important to note that the software developed in this project will run on any robot satisfying the sensor and communication requirements by changing the parameters to match in the source code. The Turtlebot has all the required hardware apart from a {\color{red} designated communication unit}. As this project focuses on simulation, the simulator will be responsible for passing messages between robots as they are sent. The software implementation is therefore {\color{red} communication method agnostic} as long as the messages the robots send are received by the other robots.

% TODO: Maybe mark the sensors on the robot
\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.55\textwidth]{figures/tb4.png}
    \end{center}
    \caption{Turtlebot 4}\label{fig:tb4}
\end{figure}



\section{Software Structure}
% TODO: Find a home for this figure
% TODO: Find a nice color scheme
% TODO: Refer to this figure in the text
\begin{figure}
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/software-structure.pdf}
    \end{center}
    \caption{Software structure of the project. Black arrows indicate a library dependency and green arrows denote Ros 2 communication through topics. Square boxes are Rust crates while green circles are Ros 2 nodes. Notice that the core library \texttt{botbrain} is not part of the Ros 2 dependent code. It can therefore be used by the simple simulator without Ros 2.}\label{fig:}
\end{figure}


The software is divided into three main parts, the robot behavior implementation, a simple custom 2D
simulator, and a ROS2 environment.

\subsection{Robot Behavior}
The robot behaviors are implemented in the botbrain rust crate. This crate defines the Robot interface
which is the only way for outside crates to interact with a robotâ€™s internal state (see \cref{fig:robot-interface}).

\begin{figure}[H]
    \begin{center}
        \begin{minted}[autogobble]{rust}
            pub trait Robot {
                fn set_id(&mut self, id: RobotId);            // Set the id of the robot
                fn set_world_size(&mut self, size: Vec2);     // Set the size of the world

                fn input_pose(&mut self, pose: RobotPose);    // Input the angle of the robot
                fn input_cam(&mut self, cam: CamData);        // Input data from the camera
                fn input_lidar(&mut self, lidar: LidarData);  // Input data from the lidar
                fn input_msgs(&mut self, msgs: Vec<Message>); // Input messages from other robots

                fn get_id(&self) -> &RobotId;                 // Get the id of the robot
                ...
            }
        \end{minted}
    \end{center}
    \caption{Methods of the \texttt{Robot} interface.}\label{fig:robot-interface}
\end{figure}

Interface methods prefixed with \texttt{set} are used to set up the internal state of the robot and should be called after creating a robot and before any other methods. The \texttt{input} prefix is used in functions which should be called as often as possible to update the world view of the robot. \texttt{get}-methods do not change the state of the robot and may be called at any time. Notice that there is no method which "runs" the robot to generate a control signal. This is because a \texttt{Robot} only represents the robot state, not the algorithm which uses that state to generate a control output. To generate a control output, the dynamic \texttt{Robot} must be passed to a behavior function as defined in \cref{fig:behavior-fn}. This function is then free to read and write to the robot state, to generate a control signal as well as a list of messages which should be sent to the other robots.

\begin{figure}[H]
    \begin{center}
        \begin{minted}[autogobble]{rust}
            pub type BehaviorFn = fn(&mut Box<dyn Robot>, Duration) -> (Control, Vec<Message>);
        \end{minted}
    \end{center}
    \caption{Definition of a behavior function.}\label{fig:behavior-fn}
\end{figure}

Separating the robot state from its behavior allows multiple behaviors for the same internal state, which is useful for comparing different algorithms.

\subsection{Using Rust}
% TODO: Describe how we integrated with colcon
The {\color{red} functionality} of this project is entirely written in rust. Although this choice was mostly due to preference, it does have a few benefits, but has also been a {\color{red} disadvantage} at times. Ros 2 {\color{red} does not officially support Rust} and it can therefore be a bit tricky to integrate with Ros 2 and \texttt{colcon}. To use Ros 2 from Rust, a library by the name \texttt{r2r} was used {\color{red}[CITE]}, which provides bindings for the Ros 2 api and generates code for Ros 2 message types. It works great although compile times are a bit long.

% TODO: Take a look at this again...
An advantage of writing everything in Rust is the robustness and correctness of the code. The rust compiler ensures that undefined behavior is impossible and enforces a very strict type system where object lifetimes are verified at compile time. We can therefore, with a say that the code will not do anything unexpected.

\subsection{Two Simulators}
% TODO: Why two simulators?
% TODO: Shared behavior
% TODO: Performance differences
