\section{Search Algorithms}search
This section describes the development of a distributed algorithm which makes it possible for a group of robots to find a search item. These algorithms are implemented in the \texttt{botbrain} library.

This project explores two approaches for controlling the behavior of the robot swarm: A {\color{red} manually developed} algorithm and an algorithm based on reinforcement learning. The following sections will explore the development of these.

\section{{\color{red}Manually Developed Algorithm}}

\subsection{Target Contributions}
A robot keeps track of a lot of state which should dictate how it moves and explores the environment. Different inputs may indicate that the robot should do different things at the same time. This could be in the situation where the robot knows that there is unexplored area in front of it, but it is blocked by an obstacle. The exploration part of the behavior may tell the robot to move towards the unexplored area while the obstacle avoidance part of the behavior may {\color{red} tell} the robot to move away from the obstacle. All of these subsystem outputs must be combined to create a behavior which is {\color{red} controlled by all subsystems at the same time}. To resolve this, each subsystem outputs a "target" vector, which signifies the direction the robot should move. All of these target vectors are summed to get a single target vector which specifies the direction that the robot should move. Each subsystem can be weighted to make the robot more responsive to that subsystem. The obstacle avoidance subsystem should be weight highly, as the robot should try very hard, not to run into obstacles. \Cref{fig:target-contributions} shows an example of this procedure.

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.75\textwidth]{figures/target-contribtions.png}
    \end{center}
    \caption{Example of the target calculation}
    \label{fig:target-contributions}
\end{figure}


% TODO: Describe the idea, that different factors contribute to the target vector. The target vector is the sum over all contributions.
% TODO: Describe how we take gradients on a grid

\subsection{Search Grid}

Each robot has a "search grid" which is continuously updated by observations by the robot itself, and the observations of other robots which it receives over the shared communication channel. The "search grid" can be thought of as a heat map, where well explored areas are "colder" and less explored areas are "hotter". If communication is loss less, the internal "search grids" of all robots should always be in sync. Each robot will then calculate their desired trajectory vector by taking a gradient over the "search grid" at their position (see \cref{fig:search-gradient}). This results in behavior where robots will seek out unexplored areas near them.

\begin{figure}[h]
    \begin{center}
        % TODO: Actully create figure
        \includegraphics[width=0.45\textwidth]{./figures/search-gradient.png}
    \end{center}
    \caption{How the search gradient is calculated}
    \label{fig:search-gradient}
\end{figure}


% TODO: Can we write "we"?
In practice, taking the gradient is not as simple as it may seem. First we must calculate the "heat" under the robot ($H$). This is accomplished with an average over the cells underneath the robot ($C_\mathrm{robot}$) as in \cref{eq:robot-heat}.

\begin{equation}
\label{eq:robot-heat}
    H = \frac{1}{N} \sum_c^{C_\mathrm{robot}} \mathrm{heat}(c)
\end{equation}

We can now draw a vector from the robot position $P$, to all grid cells within some radius ($C_\mathrm{r}$). We call this vector $\mathbf{d}$.
\begin{equation}
    \mathbf{d} = \mathrm{pos}(c) - P, \quad \forall c \in C_\mathrm{r}
\end{equation}

Every cell contributes to the gradient, in the direction of $\mathbf{d}$ with the weight of the difference in heat between the cell and the robot. We also weight closer cells higher than cells further away. This smooths out the gradient changes as the robot moves around by gradually fading out the effect of a cell as it gets closer the gradient cutoff distance.
\begin{equation}
    \nabla = \sum_c^{C_\mathrm{r}} \;
    \underbracket{\; \mathbf{d}/\norm{\mathbf{d}}      \;}_\text{\makebox[0pt]{Direction}} \cdot
    \underbracket{\; \big(\mathrm{heat}(c) - H\big)    \;}_\text{Heat Diff.} \cdot
    \underbracket{\; \big(1 - \norm{\mathbf{d}}/r\big) \;}_\text{Nearness}
\end{equation}

This gradient performs well within the map, but leads to problems near the map edges. Cells outside the map have no "temperature". {\color{red}So}, in the case that a robot is near the edge and cells within the map are colder than the cells under the robot, the resulting gradient points to the edge of the map, even though there is nothing to explore there. \Cref{fig:edge-gradient} shows this scenario.

\begin{figure}[h]
    \begin{center}
        % TODO: Actually create figure
        \includegraphics[width=0.45\textwidth]{./figures/edge-gradient.png}
    \end{center}
    \caption{Robot gradient at the edge of the map.}
    \label{fig:edge-gradient}
\end{figure}

To mitigate this issue, the gradient equation is changed so that only positive contributions are used. In practice this means that the gradient points towards the "hottest" direction, but not necessarily away from the "coldest" direction.

\begin{equation}
\label{eq:robot-gradient}
    \nabla = \sum_c^{C_\mathrm{r}}
    \begin{cases}
        \mathbf{d}/\norm{\mathbf{d}}      \; \cdot
        \big(\mathrm{heat}(c) - H\big)    \; \cdot
        \big(1 - \norm{\mathbf{d}}/r\big) \; \quad &\text{if } \mathrm{heat}(c) > H
        \\
        0, \quad &\text{otherwise}
    \end{cases}
\end{equation}

With this gradient calculation, tho robots will explore the map by getting attracted to the most unexplored areas near them without lingering near the edges. \Cref{fig:search-no-proximity} shows the resulting behavior.

\begin{figure}[h]
    \begin{center}
        % TODO: Actually create figure
        \includegraphics[width=0.45\textwidth]{./figures/search-behavior-no-proximity.png}
    \end{center}
    \caption{Robot paths recorded during a search mission.}
    \label{fig:search-no-proximity}
\end{figure}

\subsection{Proximity Grid}
The robot should stay withing communication range of the other robots, to assure this, the robot keeps track of the connectivity {\color{red} across} the whole map using a "Proximity Grid" (See \cref{fig:proximity-grid}).

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/proximity-grid.png}
    \end{center}
    \caption{Example of a proximity grid}\label{fig:proximity-grid}
\end{figure}

The grid is calculated by the largest network of connected robots and "coloring" in the area with connectivity to this main network. A tile is halv colored if only one robot giving the tile connectivity to indicate that the connection is less reliable in these areas. A {\color{red} gradient} over the proximity is used as a weighted contribution to the target vector of the robot, which makes the robot biased towards staying withing the main network. A key aspect of calculating the proximity grid for a robot is \emph{not} including the calculating. In the situation that the robot is the only link between the main network and the other robots, the robot will move towards the main network, and therefore "pull" the stay robots along. An example of this behavior in simulation can be seen on \cref{fig::proximity-pull}.

\begin{figure}[h]
    \begin{center}
        \begin{subfigure}[b]{0.31\textwidth}
            \centering
            \includegraphics[width=\textwidth]{figures/proximity-pull1.png}
            \caption{Proximity grid for a {\color{red} single link} robot}
            \label{fig:proximity-pull1}
        \end{subfigure}
        \begin{subfigure}[b]{0.31\textwidth}
            \centering
            \includegraphics[width=\textwidth]{figures/proximity-pull2.png}
            \caption{The single link robot has moved toward the main network and is pulling the stay robots along}
            \label{fig:proximity-pull2}
        \end{subfigure}
        \begin{subfigure}[b]{0.31\textwidth}
            \centering
            \includegraphics[width=\textwidth]{figures/proximity-pull3.png}
            \caption{The stay robots have now been pulled towards the main network.}
            \label{fig:proximity-pull3}
        \end{subfigure}
    \end{center}
    \caption{Example of a {\color{red} single link} robot pulling stay robots into the network.}\label{fig:proximity-pull}
\end{figure}



% TODO: How is this populated
% TODO: Add a nice figure

\subsection{Global Planner}
% TODO: Why is if useful
\subsubsection{Costmap}\label{sec:costmap}
% TODO: Show cost map and example of a planned route
\subsubsection{Frontier Exploration}\label{sec:frontier_exploration}
% TODO: Explain frontier exploration
\subsubsection{A-star path planning}\label{sec:a_star}
% TODO: Explain A-star and straight line path generation
\subsubsection{Pathing errors}\label{sec:pathing_errors}
Looser restriction on the clearence of the generated path.

Use a combination of pathing vectors and lidar contribution to follow path byt not hit obstacles and other robots.
% TODO: Explain pathing fails here or in A-star subsubsection.

